package lib

import "mate/pkg"

// Lexer is the main lexical converter of the mate.
// It converts given string Input(expression) to an array of tokens.
//
// > VISUAL EXAMPLE OF LEXER
//
//      USER INPUT
//     ╭──────────────────────────╮
//     │ (4 * 5 - 5) * 2 + 24 / 2 │
//     ╰──────────────────────────╯
//
//      OUTPUT OF THE LEXER
//     ╭───────────────────────────────────╮
//     │                                   │    ╭─▶ First Sub Expression
//     │   ╭───────────────────────────╮   │    │
//     │   │                           │────────╯
//     │   │   ╭───────────────────╮   │   │
//     │   │   │                   │─╮ │   │
//     │   │   │   ╭───────────╮   │ │ │   │
//     │   │   │   │ NUMBER(4) │   │ ╰────────────▶ Second Sub Expression
//     │   │   │   │ PRODUCT   │─╮ │   │   │        Which belongs to first sub expression.
//     │   │   │   │ NUMBER(5) │ │ │   │   │
//     │   │   │   ╰───────────╯ ╰──────────────╮
//     │   │   │    MINUS          │   │   │    │
//     │   │   │    NUMBER(5)      │   │   │    ╰─▶ Third Sub Expression
//     │   │   │                   │   │   │        Which belongs to second sub expression.
//     │   │   ╰───────────────────╯   │   │
//     │   │                           │   │
//     │   │    PRODUCT                │   │
//     │   │    NUMBER(2)              │   │
//     │   │                           │   │
//     │   ╰───────────────────────────╯   │
//     │                                   │
//     │    PLUS                           │
//     │                                   │
//     │   ╭──────────────────────────╮    │    ╭─▶ Fourth Sub Expression
//     │   │                          │    │    │
//     │   │  NUMBER(24)              │    │    │
//     │   │  DIVIDE                  │─────────╯
//     │   │  NUMBER(2)               │    │
//     │   │                          │    │
//     │   ╰──────────────────────────╯    │
//     │                                   │
//     ╰───────────────────────────────────╯
//
type Lexer struct {
	Input        string // Expression Input.
	Char         byte   // Current char under examination.
	position     int    // Current position in input (points to current char).
	readPosition int    // Current reading position in input (after current char).
}

// NewLexer is default way of creating a new Lexer object.
func NewLexer(input string) Lexer {
	lexer := Lexer{Input: input}

	// Activates lexer for further usage.
	// Fills, Char, position, and readPosition.
	lexer.readChar()

	return lexer
}

// Lex loops through the Input, converts each char to a understandable token
// variable, as a result we'd got a list of tokens, which will be used to calculate
// final result of expression or check for validness of expression.
func (l *Lexer) Lex() []Token {
	tokens := []Token{}

	for l.Char != 0 {
		token := l.GenerateToken()
		tokens = append(tokens, token)
	}

	return tokens
}

// GenerateToken converts [l.Char] to token.
func (l *Lexer) GenerateToken() Token {
	l.skipWhitespace()

	// Check if it's supported token or operation sign.
	if lit, isSign := strToTokenType[string(l.Char)]; isSign {
		// Boolean to determine if that negative number could be created.
		isFreeFromNum := !pkg.IsNumber(l.peekCharBack())

		// Check if next is number and we're
		// face-to-face with negative number.
		nextIsNumber := pkg.IsNumber(l.peekChar())

		// Generate negative or positive number
		// by validating each [above] cases.
		if pkg.IsPlusOrMinus(string(l.Char)) && isFreeFromNum && nextIsNumber {
			num := l.readNumber()
			return NewToken(num)
		}

		l.readChar()
		return NewToken(lit.ToStrValue())
	}

	// Check if it's number
	if pkg.IsNumber(string(l.Char)) {
		num := l.readNumber()
		return NewToken(num)
	}

	ch := l.Char
	l.readChar()

	return NewToken(string(ch))
}

// CombineTokens takes first-party tokens, combines them and returns
// fully-ready (final)tokens for calculation.
//
//   Before - (First Party Token)
//   ─────────────────────────────────
//   An array of tokens - which is generated by [Lex].
//   Has absolutely no sub-tokens which could be imagined
//   as 1D array, with no nesting.
//  ╭────────╮ ╭────────╮ ╭──────╮ ╭────────╮ ╭────────╮
//  │ LPAREN │ │ NUMBER │ │ PLUS │ │ NUMBER │ │ RPAREN │
//  ╰────────╯ ╰────────╯ ╰──────╯ ╰────────╯ ╰────────╯
//
//   After - (Final Token)
//   ─────────────────────────────────
//   By combining a parentheses equation token list
//   We'd got a one-base token - [Sub Token].
//   Which has three sub tokens inside ──▶ NUMBER - PLUS - NUMBER.
//  ╭────────────────────────────────╮
//  │ ╭────────╮ ╭──────╮ ╭────────╮ │
//  │ │ NUMBER │ │ PLUS │ │ NUMBER │ │
//  │ ╰────────╯ ╰──────╯ ╰────────╯ │
//  ╰────────────────────────────────╯
//
func (l *Lexer) CombineTokens(tokens []Token) []Token {
	combinedTokens := []Token{}

	// TODO: Add functionality.

	return combinedTokens
}

// peekChar returns next char of current position.
func (l *Lexer) peekChar() string {
	if l.readPosition >= len(l.Input) {
		l.Char = 0
	}

	return string(l.Input[l.readPosition])
}

// peekChar returns previous char by current position.
func (l *Lexer) peekCharBack() string {
	index := l.position - 1
	if index < 0 {
		return ""
	}

	return string(l.Input[index])
}

// skipWhitespace skips white(empty) spaces and updates state of lexer (by readChar).
func (l *Lexer) skipWhitespace() {
	for l.Char == ' ' || l.Char == '\t' || l.Char == '\n' || l.Char == '\r' {
		l.readChar()
	}
}

// readChar is character reading functionality, which also updates state of lexer.
// If readPosition limit exceeded, appends 0 to lexer's char. (which means end of reading input)
func (l *Lexer) readChar() {
	if l.readPosition >= len(l.Input) {
		l.Char = 0
	} else {
		l.Char = l.Input[l.readPosition]
	}

	// Update positions.
	l.position = l.readPosition
	l.readPosition += 1
}

// readNumber goes and collects from start to end of
// the string number, and returns the full part of that number from input.
//
//  "-426.7" actually is a array of [rune]s
//  ╭───────────────────────────────────────────╮
//  │ 426.7 ───▶ ['-', '4', '2', '6', '.', '7'] │
//  ╰───────────────────────────────────────────╯
//   To make computer understood that full number,
//   We need to determine the start and end index
//   of that full-number in rune array (from digit to digit).
//
func (l *Lexer) readNumber() string {
	start := l.position

	// Include negative/positive representation signs.
	if pkg.IsPlusOrMinus(string(l.Input[start])) {
		l.readChar()
	}

	// Keep reading forward chars if l.Char is number or number-point.
	for pkg.IsNumber(string(l.Char)) || pkg.IsPoint(string(l.Char)) {
		l.readChar()
	}

	return l.Input[start:l.position]
}
